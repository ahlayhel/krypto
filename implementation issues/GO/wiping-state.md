A basic rule for writing cryptographic implementations is to wipe any secrets as soon as they're no longer needed.  The longer a secret is kept, the higher the chance that someone
will be able to access it.  For transient secrets, this involves wiping the memory locations.  This has to be done intentionally by the developer as some operating systems don't bother
wiping out the memory before they give it to the next application.

More specifically, any time local secrets are created and used in a function, those secrets must be destroyed before function exit.  One can't rely on GO to scrub-clean the stack upon exit.  What can happen is that stack will unwind throwing away the references to secret objects without cleaning the objects themselves.  This mean that those secrets could end up somewhere on the heap.  While it is true that GO has a garbage collector to clean the heap, there are no specifications as to how often the garbage collector is run.  So it is quite conceivable that secrets could remain in memory for a very long time.

The way to zeroize the secrets is to write zeros or random data over the data structures that store them.  In GO, secrets must always be kept in byte arrays or slices (of the form []byte) since they're immutable and have a way to control buffer overflow (by using a slice as part of an array with max length).  Secrets for example must not be kept in strings which are immutable.  Even then, the work is not done.  Some GO compilers might optimize away this zeroization code at the end of the function.  Reason being, GO might reason that these new values being fed into the byte array are not used anywhere (they're being dumped upon function exit), hence this whole zeroization operation can be discarded. Whenever possible, check the code the compiler produces and make sure secrets are indeed wiped.

Another thing that can be done here is to look into memguard. I haven't had a chance to look at it myself so not sure how good or secure it is.  Also, not sure what kind of performance hit it will cost.
